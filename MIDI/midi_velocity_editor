desc:MIDI Velocity Editor
//tags: MIDI processing
import JackUtilities/mSL_StM_Memory.jsfx-inc
import JackUtilities/mSL_Dyn_Memory.jsfx-inc
import JackUtilities/mSL_Mem_Dbg.jsfx-inc
import GFX/gfx_functions.jsfx-inc

in_pin:none
out_pin:none

slider1:64<0,127,1>Min
slider2:64<0,127,1>Max

@init
gfx_err = 0;
mSL_StM_GlobFlgs=mSL_StM_FlFill+mSL_StM_FlSigErr+mSL_StM_FlCheck;

mSL_StM_Init(1024);
static_table = mSL_StM_Alloc(128, 'data', mSL_StM_FlClear);
mem = mSL_StM_BlockStart('XXXX');
chk0 = mSL_StM_Check();
chk1 = mSL_StM_Check(mem);
dyn = mSL_Dyn_Init(mem-2, mem[-1]+4);
chk2 = mSL_StM_Check(mem);
chk3 = mSL_StM_Check();
chk4 = mSL_Dyn_Check(128);

ext_noinit = 1.0;
notes_on = mSL_Dyn_Alloc(88, 'midi', mSL_StM_FlClear);
prev_on = mSL_Dyn_Alloc(88, 'midi', mSL_StM_FlClear);
velocities = mSL_Dyn_Alloc(176, 'midi', mSL_StM_FlClear);
i = 0;
loop(88,
  notes_on[i] = 0;
  prev_on[i] = 0;
);
i = 0;
loop(88,
  velocities[2*i] = -1;
  velocities[2*i+1] = -1;
  i += 1;
);
inverted_mat = mSL_Dyn_Alloc(16, 'mats', mSL_StM_FlClear);
vec =  mSL_Dyn_Alloc(4, 'vecs', mSL_StM_FlClear);
m1 = mSL_Dyn_Alloc(16, 'mats', mSL_StM_FlClear);
m2 = mSL_Dyn_Alloc(16, 'mats', mSL_StM_FlClear);
rot = mSL_Dyn_Alloc(16, 'mats', mSL_StM_FlClear);
res = mSL_Dyn_Alloc(4, 'vecs', mSL_StM_FlClear);
make_vec(1, 0, 0, vec);
make_mat_rot('z', $pi / 4.0, m1);
make_mat_rot('x', $pi / 4.0, m2);
mat_mult(m1, m2, rot);
apply_mat(vec, rot, res);
#out = "";
gfx_init();
gfx_ortho(-10, 10, -5, 5, 10, -10);
print_mat(#out, gfx_view_mat);

@serialize
file_mem(0,notes_on,5*88);

@slider

@block
while (midirecv(offset, msg1, msg2, msg3)) (
  (msg1 === 0x90) ? (
    notes_on[msg2 - 21] = msg3;
    curr_idx = 2 * (msg2 - 21);
    curr_min = velocities[curr_idx];
    velocities[curr_idx] = (
      (velocities[curr_idx] === -1)
      ? msg3
      : min(velocities[curr_idx], msg3)
    );
    velocities[curr_idx + 1] = (
      (velocities[curr_idx + 1] === -1)
      ? msg3
      : max(velocities[curr_idx + 1], msg3)
    );
    slider1 = velocities[114]; sliderchange(slider1);
    slider2 = velocities[115]; sliderchange(slider2);
  );
  (msg1 === 0x80) ? (
    prev_on[msg2 - 21] = notes_on[msg2 - 21];
    notes_on[msg2 - 21] = 0x00; 
  );
  midisend(offset, msg1, msg2, msg3);
  1;
);

@gfx 360 360
padding = 100;

gfx_x = padding;
gfx_y = gfx_h - padding;
gfx_set(255, 255, 255, 0.2);

gfx_lineto(gfx_w - padding, gfx_y);

i = 0;
bar_width_with_margin = (gfx_w - (2 * padding)) / 87.75;
bar_width = 0.75 * bar_width_with_margin;

bar_max_height = (gfx_h - (2 * padding));
bar_height_per_velocity = bar_max_height / 127;
begin_y = gfx_h - padding;
loop(
  88,
  // draw max bars
  gfx_set(255, 255, 255, 0.2);
  begin_x = i * bar_width_with_margin + padding;
  end_x = begin_x + bar_width;
  gfx_rect(begin_x, begin_y - bar_max_height, bar_width, bar_max_height);
  
  
  
  // draw min-max
  gfx_set(255, 255, 255, 0.5);
  min_vel = velocities[2 * i] === -1 ? 0 : velocities[2 * i];
  max_vel = velocities[2 * i + 1] === -1 ? 127 : velocities[2 * i + 1];
  bar_min = bar_height_per_velocity * min_vel;
  bar_max = bar_height_per_velocity * max_vel;
  gfx_rect(begin_x, begin_y - bar_max, bar_width, bar_max - bar_min);
  
  // draw current velocity
  bar_height = (bar_height_per_velocity * notes_on[i]);
  end_y = begin_y - bar_height;
  gfx_set(255, 255, 255, 0.8);
  gfx_rect(begin_x, end_y, bar_width, bar_height);
  
  // draw current velocity
  gfx_set(255, 255, 255);
  gfx_line(begin_x, end_y, end_x, end_y);
  
  // draw last velocity if current note is off and last velocity was not 0
  (notes_on[i] === 0 && prev_on[i] !== 0) ? (
    gfx_set(255, 255, 255, 0.4);
    bar_height = (bar_height_per_velocity * prev_on[i]);
    end_y = begin_y - bar_height;
    gfx_line(begin_x, end_y, end_x, end_y);
  );
  i += 1;
);
